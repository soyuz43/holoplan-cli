// src/runner/pipeline.go
package runner

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"

	"holoplan-cli/src/agents"
	"holoplan-cli/src/shared"
	"holoplan-cli/src/types"
	"holoplan-cli/src/validator"

	"github.com/beevik/etree"
	"gopkg.in/yaml.v3"
)

const MaxCorrections = 1

// RunPipeline now accepts a format ("drawio" or "figma")
func RunPipeline(yamlPath string, format string) error {
	stories, err := loadStories(yamlPath)
	if err != nil {
		return fmt.Errorf("failed to load stories: %w", err)
	}

	for _, story := range stories {
		fmt.Printf("üîç Processing Story: %s\n", story.ID)

		viewPlan, ok := safeChunk(story)
		if !ok {
			log.Printf("‚ö†Ô∏è Failed to chunk story: %s ‚Äî skipping\n", story.ID)
			continue
		}

		for _, view := range viewPlan.Views {
			fmt.Printf("‚öôÔ∏è  Generating view: %s\n", view.Name)

			output, ok := safeBuild(view, story, format)
			if !ok {
				log.Printf("‚ö†Ô∏è Failed to build layout for view: %s\n", view.Name)
				continue
			}

			// Only audit and resolve for Draw.io (XML-based)
			if format == "drawio" {
				// Audit the initial XML using view.Narrative
				critique, ok := safeAudit(view.Narrative, output)
				if !ok {
					log.Printf("‚ö†Ô∏è Failed to audit layout for view: %s\n", view.Name)
					continue
				}

				// Attempt resolution only if there are issues and within MaxCorrections
				if critique.HasIssues() {
					fmt.Printf("üîÅ Correction attempt 1 for %s\n", view.Name)
					// Pass view.Narrative to Resolve
					resolvedXML, ok := safeResolve(output, critique, view.Narrative)
					if ok {
						output = resolvedXML // Use resolved XML if successful
					} else {
						log.Printf("‚ö†Ô∏è Resolve failed at attempt 1 ‚Äî proceeding with original XML\n")
					}
				} else {
					log.Printf("‚úÖ No issues found in initial audit for view: %s", view.Name)
				}

				// Skip re-auditing the corrected XML
				output = shared.ForceQuoteAllAttributes(output)
				if err := validator.CheckLayout(output); err != nil {
					log.Printf("‚ùå Layout validation failed: %v", err)
				} else {
					fmt.Println("‚úÖ Spatial layout passed")
				}
			} else {
				// For Figma, no audit/resolver/validation yet
				fmt.Println("‚úÖ Figma layout generated (no audit/validation yet)")
			}

			err = saveOutput(story.ID, view.Name, output, format)
			if err != nil {
				log.Printf("‚ö†Ô∏è Failed to save output: %v", err)
			}
		}
	}

	// Only merge for Draw.io
	if format == "drawio" {
		if err := mergeDrawio("output/final.drawio"); err != nil {
			return fmt.Errorf("failed to merge drawio files: %w", err)
		}
	}

	fmt.Println("[‚úì] Pipeline completed successfully")
	return nil
}

func loadStories(path string) ([]types.UserStory, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	var stories []types.UserStory
	err = yaml.Unmarshal(data, &stories)
	return stories, err
}

func safeChunk(story types.UserStory) (types.ViewPlan, bool) {
	defer recoverLLM("Chunk")
	return agents.Chunk(story), true
}

// Updated to accept format
func safeBuild(view types.ViewLayout, story types.UserStory, format string) (string, bool) {
	defer recoverLLM("Build")
	output := agents.Build(view, story, format)

	if format == "drawio" {
		// Ensure XML is quoted before validation
		output = shared.ForceQuoteAllAttributes(output)

		// Validate XML syntax
		doc := etree.NewDocument()
		if err := doc.ReadFromString(output); err != nil {
			log.Printf("‚ö†Ô∏è Invalid XML generated by Build: %v", err)
			return "", false
		}
	}

	return output, true
}

func safeAudit(narrative string, xml string) (types.Critique, bool) {
	defer recoverLLM("Audit")
	return agents.Audit(narrative, xml), true
}

func safeResolve(xml string, critique types.Critique, narrative string) (string, bool) {
	defer recoverLLM("Resolve")
	return agents.Resolve(xml, critique, narrative), true
}

func recoverLLM(agent string) {
	if r := recover(); r != nil {
		log.Printf("üî• Panic recovered in %s agent: %v\n", agent, r)
	}
}

// Updated to save .json for Figma
func saveOutput(storyID, viewName string, content string, format string) error {
	if err := os.MkdirAll("output", os.ModePerm); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Combine storyID and viewName, then sanitize
	base := sanitize(fmt.Sprintf("%s_%s", storyID, viewName))

	var filename string
	if format == "figma" {
		filename = filepath.Join("output", base+".figma.json")
	} else {
		filename = filepath.Join("output", base+".drawio")
	}

	if err := os.WriteFile(filename, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}

func sanitize(name string) string {
	// Keep hyphens and underscores, just replace spaces and convert to lowercase
	name = strings.ReplaceAll(strings.TrimSpace(name), " ", "_")
	return strings.ToLower(name)
}

// mergeDrawio builds a valid <mxfile> with one <diagram> per input .drawio file.
func mergeDrawio(outputPath string) error {
	files, err := filepath.Glob("output/*.drawio")
	if err != nil {
		return fmt.Errorf("failed to scan output files: %w", err)
	}

	if len(files) == 0 {
		return fmt.Errorf("no .drawio files found in output directory")
	}

	finalDoc := etree.NewDocument()
	finalDoc.CreateProcInst("xml", `version="1.0" encoding="UTF-8"`)
	mxfile := finalDoc.CreateElement("mxfile")

	for _, file := range files {
		content, err := os.ReadFile(file)
		if err != nil {
			return fmt.Errorf("failed to read %s: %w", file, err)
		}

		// Basic validation
		offenders, err := shared.DetectEscapedFillColors(string(content))
		if err != nil {
			return fmt.Errorf("[x] Error detecting escaped colors in %s: %w", file, err)
		}
		if len(offenders) > 0 {
			return fmt.Errorf("[x] Escaped fillColor values detected in %s: %v", file, offenders)
		}

		// Parse the input file
		subDoc := etree.NewDocument()
		if err := subDoc.ReadFromString(string(content)); err != nil {
			return fmt.Errorf("failed to parse XML in %s: %w", file, err)
		}

		// Find the <mxGraphModel> element
		model := subDoc.FindElement("//mxGraphModel")
		if model == nil {
			return fmt.Errorf("no <mxGraphModel> found in %s", file)
		}

		// Create a <diagram> element and append the <mxGraphModel> into it
		diagram := mxfile.CreateElement("diagram")

		// Clean up the filename for the diagram name
		baseName := filepath.Base(file)
		diagramName := strings.TrimSuffix(baseName, filepath.Ext(baseName))
		diagram.CreateAttr("name", diagramName)

		// Add the model to the diagram
		diagram.AddChild(model.Copy())
	}

	// Serialize to string with proper formatting
	finalDoc.Indent(2)
	finalXML, err := finalDoc.WriteToString()
	if err != nil {
		return fmt.Errorf("failed to serialize final <mxfile>: %w", err)
	}

	// Validate the final XML structure
	validateDoc := etree.NewDocument()
	if err := validateDoc.ReadFromString(finalXML); err != nil {
		return fmt.Errorf("üö® final merged <mxfile> is malformed: %w", err)
	}

	return os.WriteFile(outputPath, []byte(finalXML), 0644)
}
